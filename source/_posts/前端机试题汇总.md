---
title: 前端机试题汇总
date: 2018-03-09 23:24:28
tags:
---
**1、**将字符串str="hEllO Word"的字母大小写相互转换，并且倒叙输出，得到结果为"wORD HeLLo"。
```
	var str="hEllO Word";
	var STR="";
	for(var i=0;i<str.length;i++){
		//顺序判断字母是否大写，如果是大写就转换为小写，反正亦然
		STR+=/[A-Z]/.test(str[i])?str[i].toLowerCase():str[i].toUpperCase();
	}
	STR=STR.split(" ").reverse();//分割为数组再对数组顺序进行颠倒
	console.log(STR.join())
```
**2、**将字符串num=321进行倒叙，得到结果为123，若num=1000，则倒叙结果应该为1（字符串前的0应该去掉）。
```
	function change(get){
		var ans="";
		get=get.toString();
		for(var i=get.length-1;i>=0;i--){
			ans+=get[i]
		}
		ans=ans.replace(/^0+/g,"")
		console.log(ans)
	}
	change(321);
	change(1000);
```
**3、**函数声明、优先级、实例化等操作。
```
	function Goo(){
		getName=function(){
			console.log(1)
		}
		return this;
	}
	Goo.getName=function(){console.log(2)}
	Goo.prototype.getName=function(){console.log(3)}
	var  getName=function(){console.log(4)}
	function getName(){console.log(5)}
	问：
	Goo.getName();
	getName();
	Goo().getName();
	getName();
	new Goo.getName();
	new Goo().getName();
	new new Goo().getName();
	
	（1）Goo.getName();//2
		/*读取的是Goo的静态属性，即Goo.getName=function(){console.log(2)}*/  

	（2）getName();//4
		/*
		有个区别就是:var a=function()和function a()。如下:
		a();//输出1
		var a=function(){console.log(2)}
		a()//输出2
		function a(){console.log(1)}
		a()//输出2

		为什么上面输出的结果是：1=>2=>2？

		解释一下：
		***首先，我们要知道，比如一个页面里函数的初始化，我们是不是写好一个函数，然后在这个函数前面写调用方法一样能执行。其实这是"JavaScript 解释器中存在一种变量声明被提升的机制，也就是说函数声明会被提升到作用域的最前面，即使写代码的时候是写在最后面，也还是会被提升至最前面，如function a(){console.log(1)}"
		***而用函数表达式创建的函数是在运行时进行赋值，且要等到表达式赋值完成后才能调用，如var a=function(){console.log(2)}（这个也等于 var a;a=function(){console.log(2)}）

		==>所以这么一说，这里的执行已经是var进行函数声明过后了，所以getName()输出4;
		*/

	（3）Goo().getName();//1
		/*
		首先运行Goo(),看Goo,里面有一个getName=function(){console.log(1)};这里我们注意，这是一个赋值语句，因为他没有var等定义，所以这个时候会向本作用域寻找有没有变量getName;如果没有的话，就一直往外找。所以运行这个方法过后得到的一个结果就是将getName=function(){console.log(4)}重新赋值为getName=function(){console.log(1)};为什么？因为第一句说的没有var等定义。同时，这时候返回this，this指向window，所以接着会找getName()函数去运行，所以得到结果1。
		注意，我们来个扩展，如果我们在Goo().getName()之后再次执行getName()会得到什么？是1吧（答案）？也就是下一个问的了。
		*/
	（4）getName();//1
		/*
		由上一问的解释我们得到getName被赋值为getName=function(){console.log(1)};所以为1
		*/
	（5）new Goo.getName();//2
		/*
		根据函数优先级new Goo.getName()=new (Goo.getName)();相当于把Goo.getName当成是构造函数，而Goo.getName=function(){console.log(2)};所以得到结果为2。
		顺序为Goo.getName->new->()
		*/
	（6）new Goo().getName();//3
		/*
			也是根据优先级得到new Goo().getName()=(new Goo()).getName()

			首先我们函数的静态属性、方法是不可以调用的，所以无法实例；然后this.?（公有方法）其实也是相当于实例（最终返回的是实例化对象），如
			function a(){this.getName=function(){console.log(1)}}
			new a().getName()得到结果是1;
			假设是：
			function Goo(){
				getName=function(){
					console.log(1)
				}
			}
			new a().getName()是不能执行的。
			Goo.getName=function(){
				console.log(2)
			}
			new a().getName()还是不能执行的。

			然后实例化这个操作（new），假设构造函数中没有实例化对象（公共方法=>this.??）,它就会去原型对象中（prototype）查找，但是如果同时拥有公有方法（this.）和原型链的且相同话，实例化之后找公有方法。如：
			function Goo(name) {
				this.name = name
				this.getName = function() {
					return this.name
				}
			}
			Goo.prototype.name = '2';
			Goo.prototype.getName = function() {
				return '2'
			}
			console.log((new Goo('1')).name)//1=>同时拥有返回公有方法
			console.log((new Goo('1')).getName())//1=>同时拥有返回公有方法
		*/
	（7）new new Goo().getName();//3
		/*
		只是多了一个new，和new一个性质，同上题一个结果
		*/
		
		小结论：
		***调用公有方法，公有属性，我们必需先实例化对象，也就是用new操作符实化对象，就可构造函数实例化对象的方法和属性，并且公有方法是不能调用私有方法和静态方法的
		***静态方法和静态属性就是我们无需实例化就可以调用（如第一题）
		***而对象的私有方法和属性,外部是不可以访问的
	
```